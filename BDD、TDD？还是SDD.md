---
date created: 260206
date modified: 260207
title: BDD、TDD？还是SDD
---
- **“AI 时代的 BDD”，其实就是“写清楚你想要什么（Spec/Prompt），然后让 AI 给你写个带有测试的实现”**，即是SDD。
 - TDD（测试驱动开发）和 BDD（行为驱动开发）经常被放在一起讨论，甚至 BDD 被认为是 TDD 的进化版，但它们解决的是**完全不同维度的问题**。
- 简单的一句话总结：**TDD 关注“把事情做对”（Do the thing right），而 BDD 关注“做正确的事”（Do the right thing）。**
# 建议：双剑合璧
最好的开发流通常是 **外层 BDD + 内层 TDD**：
1. **外层 (BDD)**：用 Gherkin 描述“用户登录”这个大功能。（保证做的是正确的事）
2. **红 (Fail)**：运行 BDD 测试，理所当然地失败了。
3. **内层 (TDD)**：为了让 BDD 的第一步通过（比如“验证邮箱格式”），开发者切换到 TDD 模式，写一个小的单元测试来验证 `isValidEmail` 函数。
4. **循环**：通过一个个小的 TDD 循环，最终点亮外层那个大的 BDD 绿灯。
**对于你现在想用 AI 辅助开发**： 建议先从 **BDD** 入手。因为 AI 最容易犯的错就是“听不懂人话”或者“不仅没实现功能还自己造了孽”。用 Gherkin 这种强逻辑语言约束 AI，是性价比最高的手段。
### 1. 外层（Outer Loop）：BDD —— 验收测试

这个圈子很大，跑一圈可能需要几十分钟甚至几小时。
- **关注点**：**“这个功能做完了吗？”**
- **语言**：Gherkin (Given/When/Then)。
- **粒度**：粗。比如“用户成功购买商品”。这一句话背后可能包含几十个代码函数。
- **状态**：当把所有的细节都填满后，它才会变成🟢（通过）。
### 2. 内层（Inner Loop）：TDD —— 单元测试

**这个圈子很小，跑一圈只需要几毫秒到几秒。**
- **关注点**：**“这个函数算对了吗？”**
- **语言**：代码 (assert x == 1)。
- **粒度**：极细。比如“计算价格函数：输入100和8折，应该输出80”。
- **状态**：会在这里飞快地循环：写个小测试🔴 -> 写代码🟢 -> 重构 -> 下一个小测试🔴...
# 以下是详细的优劣势对比：
### 1. TDD (Test-Driven Development) —— “开发者的显微镜”

TDD 是程序员的内功。它的核心视角是**代码实现 (Implementation)**。 **流程**：先写一个失败的单元测试 -> 写最少的代码通过它 -> 重构。

|🟢 优势 (Pros)|🔴 劣势 (Cons)|
|---|---|
|**代码质量极高**：因为先写测试，你的代码天生就是可测试、低耦合的（不然测试很难写）。|**学习曲线陡峭**：强迫程序员改变思维习惯非常痛苦，很多人坚持不下来。|
|**安全重构**：有了全覆盖的测试网，你可以随意修改代码结构而不怕改坏功能，心理安全感极强。|**过度关注细节**：容易陷入“为了测试而测试”的陷阱，导致测试代码比业务代码还多，且一旦重构内部逻辑，测试就会把你报错报死（脆弱性）。|
|**即时反馈**：改一行代码，1秒钟就知道对不对，调试时间大幅减少。|**只见树木不见林**：哪怕你单元测试全绿，可能拼起来的功能根本不是用户想要的。TDD **不能**防止你“完美地实现了一个错误的功能”。|

---

### 2. BDD (Behavior-Driven Development) —— “团队的通用语”

BDD 是 TDD 的外层包装。它的核心视角是**业务价值 (Business Value)**。 **流程**：先写 Gherkin 剧本 -> 转化为自动化测试 -> (内部可能包含 TDD 循环) 实现功能。

| 🟢 优势 (Pros)                                                                             | 🔴 劣势 (Cons)                                                             |
| ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **消除沟通鸿沟**：最大的价值在于它不仅是测试，更是**需求文档**。产品经理、测试和开发都能看懂 `Given/When/Then`，彻底消灭“我以为你是这个意思”的扯皮。 | **开发成本更高**：维护 Gherkin 文件、编写“胶水代码”（Step Definitions）来连接自然语言和代码，这都是额外的工作量。 |
| **活的文档**：需求变更了，必须改 Gherkin，否则测试跑不通。这保证了文档和代码永远同步，不会出现“文档是三年前的”这种情况。                      | **运行速度慢**：BDD 通常涉及端到端（E2E）或集成测试，跑一次可能几分钟甚至几十分钟，不像 TDD 单元测试几毫秒出结果。        |
| **专注于用户**：强迫开发人员从“用户怎么用”开始思考，而不是一上来就想数据库怎么建。                                             | **杀鸡焉用牛刀**：对于简单的功能或纯底层库（如一个数学计算函数），写冗长的 Gherkin 显得非常繁琐且多余。               |



### 3. 该怎么选？(结合 AI 编程)

在 AI 辅助编程时代，这两个方法的“门槛”都变低了，因为脏活累活 AI 都能干。

#### 如果你有以下情况，请侧重 **TDD**：

- **你在开发底层库或算法**：比如写一个数据解析器、加密算法。这里没有复杂的“用户行为”，更多是输入输出的逻辑正确性。
- **你需要极致的代码结构**：希望 AI 帮你写出解耦优秀的架构。
- **推荐做法**：让 AI 生成 Jest/Pytest 单元测试，然后一一实现。

#### 如果你有以下情况，请侧重 **BDD**：

- **你在开发面向用户的 App/Web**：涉及点击按钮、页面跳转、表单提交。
- **需求很复杂，容易做偏**：比如“信用卡积分兑换规则”，规则稍微错一点就是业务事故。
- **你需要向老板/客户交付**：你可以直接把运行变绿的 Gherkin 报告甩给他们看，“看，你们要的功能都通了”。
- **推荐做法**：使用我们讨论过的 Gherkin 语法，让 AI 能够理解宏观业务再动手。

